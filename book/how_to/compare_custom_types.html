<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Compare custom types - Documentation for float_eq 0.6.1</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../tutorials.html"><strong aria-hidden="true">2.</strong> Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../tutorials/basic_usage.html"><strong aria-hidden="true">2.1.</strong> Basic usage</a></li></ol></li><li class="chapter-item expanded "><a href="../how_to.html"><strong aria-hidden="true">3.</strong> How to</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../how_to/compare_floating_point_numbers.html"><strong aria-hidden="true">3.1.</strong> Compare floating point numbers</a></li><li class="chapter-item expanded "><a href="../how_to/compare_composite_types.html"><strong aria-hidden="true">3.2.</strong> Compare composite types</a></li><li class="chapter-item expanded "><a href="../how_to/interpret_assert_failure_messages.html"><strong aria-hidden="true">3.3.</strong> Interpret assert failure messages</a></li><li class="chapter-item expanded "><a href="../how_to/compare_custom_types.html" class="active"><strong aria-hidden="true">3.4.</strong> Compare custom types</a></li></ol></li><li class="chapter-item expanded "><a href="../background.html"><strong aria-hidden="true">4.</strong> Background</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../background/float_comparison_algorithms.html"><strong aria-hidden="true">4.1.</strong> Float comparison algorithms</a></li></ol></li><li class="chapter-item expanded "><a href="../api_documentation.html"><strong aria-hidden="true">5.</strong> API documentation</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../about_this_documentation.html">About this documentation</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Documentation for float_eq 0.6.1</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#how-to-compare-custom-types" id="how-to-compare-custom-types">How to compare custom types</a></h1>
<p>To extend <code>float_eq</code> functionality over a new type, you should implement the
relevant traits:</p>
<ol>
<li>
<p><a href="../../doc/float_eq/macro.float_eq.html">float_eq!</a> and <a href="../../doc/float_eq/macro.float_ne.html">float_ne!</a> require <a href="../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a> and <a href="../../doc/float_eq/trait.FloatEq.html">FloatEq</a>.</p>
</li>
<li>
<p>If your type is homogeneous, that is if it consists of fields that are all
the same underlying floating point type, you should implement the optional
<a href="../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a> to enable the <code>_all</code> comparison algorithms.</p>
</li>
<li>
<p><a href="../../doc/float_eq/macro.assert_float_eq.html">assert_float_eq!</a> and <a href="../../doc/float_eq/macro.assert_float_ne.html">assert_float_ne!</a> require the same traits plus
<a href="../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a> and <a href="../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a>. If you have implemented <a href="../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a>
you should also implement <a href="../../doc/float_eq/trait.AssertFloatEqAll.html">AssertFloatEqAll</a>.</p>
</li>
</ol>
<p>If your type is a non-generic struct or tuple struct that consists entirely of
already supported fields, then the easiest way to implement these traits is to
make use of the <code>#[derive_float_eq]</code> helper macro. It is also possible to
<code>#[derive]</code> individual traits. If you cannot derive an implementation, then you
will need to implement the traits <a href="compare_custom_types.html#implementing-the-traits-directly">directly</a>.</p>
<h2><a class="header" href="#derive_float_eq" id="derive_float_eq">#[derive_float_eq]</a></h2>
<p>If your type is a non-generic struct or tuple struct then you may derive the
relevant traits using this helper macro. Enable the &quot;derive&quot; feature by adding
this to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies.float_eq]
version = &quot;0.6&quot;
features = [&quot;derive&quot;]
</code></pre>
<p>Add <a href="../../doc/float_eq/attr.derive_float_eq.html"><code>#[derive_float_eq]</code></a> to your
type. The <code>ulps_tol</code> and <code>debug_ulps_diff</code> parameters are required. They are
used to name two new types that match the structure of the type being derived
from. The first is used to provide ULPs tolerance values per field, and the
second is used to provide debug information for the differerence between values
in ULPs.</p>
<p>The <code>all_tol</code> parameter is optional, and ought to be provided if your type
is homogeneous and consists of fields that are all the same underlying floating
point type. If provided, it will additionally implement the traits required to
use the <code>_all</code> variants of checks, using the given tolerance type (usually <code>f32</code>
or <code>f64</code>). </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive_float_eq(
    ulps_tol = &quot;PointUlps&quot;, 
    debug_ulps_diff = &quot;PointDebugUlpsDiff&quot;,
    all_tol = &quot;f64&quot;
)]
#[derive(Debug, PartialEq, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will generate the following two types in addition to implementing the
relevant extension traits. These new types will derive <code>Debug</code>, <code>Clone</code>, <code>Copy</code>
and <code>PartialEq</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointUlps {
    x: UlpsTol&lt;f64&gt;,
    y: UlpsTol&lt;f64&gt;,
}

#[derive(Debug, Clone, Copy, PartialEq)]
struct PointDebugUlpsDiff {
    x: DebugUlpsDiff&lt;f64&gt;,
    y: DebugUlpsDiff&lt;f64&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>This enables the use of your type in the <code>float_eq</code> macros:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Point { x: 1.0, y: -2.0 };
let b = Point { x: 1.1, y: -2.2 };

assert_float_eq!(a, b, abs &lt;= Point { x: 0.15, y: 0.25 });
assert_float_eq!(a, b, abs_all &lt;= 0.25);

let c = Point { x: 1.000_000_000_000_000_9, y: -2.000_000_000_000_001_3 };
let eps = f64::EPSILON;

assert_float_eq!(a, c, rmax &lt;= Point { x: 4.0 * eps, y: 5.0 * eps });
assert_float_eq!(a, c, rmax_all &lt;= 5.0 * eps);

assert_float_eq!(a, c, ulps &lt;= PointUlps { x: 4, y: 3 });
assert_float_eq!(a, c, ulps_all &lt;= 4);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#manually-derive-traits" id="manually-derive-traits">Manually #[derive] traits</a></h2>
<p>If you cannot use <code>#[derive_float_eq]</code> then you may be able to derive individual
traits manually. Enable the &quot;derive&quot; feature by adding this to your Cargo.toml:</p>
<pre><code class="language-toml">[dependencies.float_eq]
version = &quot;0.6&quot;
features = [&quot;derive&quot;]
</code></pre>
<h3><a class="header" href="#derivefloatequlpstol" id="derivefloatequlpstol">#[derive(FloatEqUlpsTol)]</a></h3>
<p>Add a <code>#[float_eq]</code> attribute and provide <code>ulps_tol</code>, which will be used as
the name of a new type. This type will be structurally identical to the type
being derived, using the same visibility as the parent type and with identically
named fields that use the derived fields' types wrapped by <code>UlpsTol</code>. The
new struct derives <code>Debug</code>, <code>Clone</code>, <code>Copy</code> and <code>PartialEq</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, FloatEqUlpsTol)]
#[float_eq(ulps_tol = &quot;PointUlps&quot;)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will generate the following struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointUlps {
    x: UlpsTol&lt;f64&gt;,
    y: UlpsTol&lt;f64&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#derivefloateq" id="derivefloateq">#[derive(FloatEq)]</a></h3>
<p>Requires <a href="../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>. Add a <code>#[float_eq]</code> attribute and provide
<code>ulps_tol</code>, which should match the name of the <code>FloatEqUlpsTol</code> type. Two
instances are equal if all fields are equal, and not equal if any are not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, FloatEqUlpsTol, FloatEq)]
#[float_eq(ulps_tol = &quot;PointUlps&quot;)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#derivefloateqall" id="derivefloateqall">#[derive(FloatEqAll)]</a></h3>
<p>Add a <code>#[float_eq]</code> attribute and specify <code>all_tol</code>, which is the type to be
used as <a href="../../doc/float_eq/trait.FloatEqAll.html#associatedtype.AllTol">AllTol</a>, usually <code>f32</code> or <code>f64</code>. Two instances are equal if all
fields are equal, and not equal if any are not.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, FloatEqAll)]
#[float_eq(ulps_tol = &quot;PointUlps&quot;, all_tol = &quot;f64&quot;)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#derivefloateqdebugulpsdiff" id="derivefloateqdebugulpsdiff">#[derive(FloatEqDebugUlpsDiff)]</a></h3>
<p>Add a <code>#[float_eq]</code> attribute and provide <code>debug_ulps_diff</code>, which will be used
as the name of a new type. This type will be structurally identical to the type
being derived, using the same visibility as the parent type and with identically
named fields that use the derived fields' types wrapped by <code>DebugUlpsDiff</code>. The
new struct derives <code>Debug</code>, <code>Clone</code>, <code>Copy</code> and <code>PartialEq</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq, FloatEqDebugUlpsDiff)]
#[float_eq(debug_ulps_diff = &quot;PointDebugUlpsDiff&quot;)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p>This will generate the following struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointDebugUlpsDiff {
    x: DebugUlpsDiff&lt;f64&gt;,
    y: DebugUlpsDiff&lt;f64&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#deriveassertfloateq" id="deriveassertfloateq">#derive[(AssertFloatEq)]</a></h3>
<p>Requires <a href="../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>, <a href="../../doc/float_eq/trait.FloatEq.html">FloatEq</a> and <a href="../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a>. Add a
<code>#[float_eq]</code> attribute and provide <code>ulps_tol</code> and <code>ulps_debug_diff</code>, which
should match the name of the <code>UlpsTol</code> and <code>DebugUlpsDiff</code> types. Each
field's tolerance is calculated via a recursive call to the algorithm being used.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
#[derive(FloatEqUlpsTol, FloatEq, FloatEqDebugUlpsDiff, AssertFloatEq)]
#[float_eq(ulps_tol = &quot;PointUlps&quot;, debug_ulps_diff = &quot;PointDebugUlpsDiff&quot;)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#deriveassertfloateqall" id="deriveassertfloateqall">#[derive(AssertFloatEqAll)]</a></h3>
<p>Requires <a href="../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>, <a href="../../doc/float_eq/trait.FloatEq.html">FloatEq</a>, <a href="../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a>, <a href="../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a>
and <a href="../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a>. Add a <code>#[float_eq]</code> attribute and provide <code>ulps_tol</code>,
<code>ulps_debug_diff</code>, and <code>all_tol</code>, which should match the names of the
<code>UlpsTol</code>, <code>DebugUlpsDiff</code> and <code>AllTol</code> types. Each field's tolerance is
calculated via a recursive call to the algorithm being used.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
#[derive(
    FloatEqUlpsTol, FloatEq, FloatEqAll,
    FloatEqDebugUlpsDiff, AssertFloatEq, AssertFloatEqAll
)]
#[float_eq(
    ulps_tol = &quot;PointUlps&quot;,
    debug_ulps_diff = &quot;PointUlpsDebugUlpsDiff&quot;,
    all_tol = &quot;f64&quot;,
)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#implementing-the-traits-directly" id="implementing-the-traits-directly">Implementing the traits directly</a></h2>
<p>If you cannot derive the implementations of the extension traits, then you may
implement them manually. These implementations will be based on the same <code>Point</code>
type as the derive examples:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct Point {
    x: f64,
    y: f64,
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-floatequlpstol" id="implementing-floatequlpstol">Implementing FloatEqUlpsTol</a></h3>
<p>Types should provide an <a href="../../doc/float_eq/type.UlpsTol.html">UlpsTol</a> representation for each of their fields:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointUlps {
    x: UlpsTol&lt;f64&gt;,
    y: UlpsTol&lt;f64&gt;,
}

impl FloatEqUlpsTol for Point {
    type UlpsTol = PointUlps;
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-floateq" id="implementing-floateq">Implementing FloatEq</a></h3>
<p>Requires <a href="../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>. Implementation is then usually a matter of
calling through to an underlying <a href="../../doc/float_eq/trait.FloatEq.html">FloatEq</a> method for each field in turn. If
not, you will need to take a close look at the descriptions of the algorithms on
a method by method basis:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FloatEq for Point {
    type Tol = Point;

    fn eq_abs(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_abs(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_abs(&amp;other.y, &amp;tol.y)
    }

    fn eq_rmax(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_rmax(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_rmax(&amp;other.y, &amp;tol.y)
    }

    fn eq_rmin(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_rmin(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_rmin(&amp;other.y, &amp;tol.y)
    }

    fn eq_r1st(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_r1st(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_r1st(&amp;other.y, &amp;tol.y)
    }

    fn eq_r2nd(&amp;self, other: &amp;Self, tol: &amp;Point) -&gt; bool {
        self.x.eq_r2nd(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_r2nd(&amp;other.y, &amp;tol.y)
    }

    fn eq_ulps(&amp;self, other: &amp;Self, tol: &amp;UlpsTol&lt;Point&gt;) -&gt; bool {
        self.x.eq_ulps(&amp;other.x, &amp;tol.x) &amp;&amp;
        self.y.eq_ulps(&amp;other.y, &amp;tol.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-floateqall" id="implementing-floateqall">Implementing FloatEqAll</a></h3>
<p>Select a tolerance type to compare recursively with each field in your type,
likely <code>f32</code> or <code>f64</code>. Implementation is then usually a matter of calling
through to an underlying <a href="../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a> method for each field in turn. If not, you
will need to take a close look at the descriptions of the algorithms on a method
by method basis:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl FloatEqAll for Point {
    type AllTol = f64;

    fn eq_abs_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_abs_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_abs_all(&amp;other.y, tol)
    }

    fn eq_rmax_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_rmax_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_rmax_all(&amp;other.y, tol)
    }

    fn eq_rmin_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_rmin_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_rmin_all(&amp;other.y, tol)
    }

    fn eq_r1st_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_r1st_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_r1st_all(&amp;other.y, tol)
    }

    fn eq_r2nd_all(&amp;self, other: &amp;Self, tol: &amp;f64) -&gt; bool {
        self.x.eq_r2nd_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_r2nd_all(&amp;other.y, tol)
    }

    fn eq_ulps_all(&amp;self, other: &amp;Self, tol: &amp;UlpsTol&lt;f64&gt;) -&gt; bool {
        self.x.eq_ulps_all(&amp;other.x, tol) &amp;&amp;
        self.y.eq_ulps_all(&amp;other.y, tol)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-floateqdebugulpsdiff" id="implementing-floateqdebugulpsdiff">Implementing FloatEqDebugUlpsDiff</a></h3>
<p>Types should provide a <a href="../../doc/float_eq/type.DebugUlpsDiff.html">DebugUlpsDiff</a> representation for each of their fields:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy, PartialEq)]
struct PointDebugUlpsDiff {
    x: DebugUlpsDiff&lt;f64&gt;,
    y: DebugUlpsDiff&lt;f64&gt;,
}

impl FloatEqDebugUlpsDiff for Point {
    type DebugUlpsDiff = PointDebugUlpsDiff;
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-assertfloateq" id="implementing-assertfloateq">Implementing AssertFloatEq</a></h3>
<p>Requires <a href="../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>, <a href="../../doc/float_eq/trait.FloatEq.html">FloatEq</a> and <a href="../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a>.
Implementation is then usually a matter of simply calling through to an
underlying <a href="../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a> method for each field in turn. If not, you will need
to take a close look at the descriptions of the algorithms on a method by method
basis:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AssertFloatEq for Point {
    type DebugAbsDiff = Self;
    type DebugTol = Self;

    fn debug_abs_diff(&amp;self, other: &amp;Self) -&gt; Point {
        Point {
            x: self.x.debug_abs_diff(&amp;other.x),
            y: self.y.debug_abs_diff(&amp;other.y),
        }
    }

    fn debug_ulps_diff(&amp;self, other: &amp;Self) -&gt; PointDebugUlpsDiff {
        PointDebugUlpsDiff {
            x: self.x.debug_ulps_diff(&amp;other.x),
            y: self.y.debug_ulps_diff(&amp;other.y),
        }
    }

    fn debug_abs_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_abs_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_abs_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_rmax_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_rmax_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_rmax_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_rmin_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_rmin_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_rmin_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_r1st_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_r1st_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_r1st_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_r2nd_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Point
    ) -&gt; Point {
        Point {
            x: self.x.debug_r2nd_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_r2nd_tol(&amp;other.y, &amp;tol.y),
        }
    }

    fn debug_ulps_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;PointUlps,
    ) -&gt; PointUlps {
        PointUlps {
            x: self.x.debug_ulps_tol(&amp;other.x, &amp;tol.x),
            y: self.y.debug_ulps_tol(&amp;other.y, &amp;tol.y),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#implementing-assertfloateqall" id="implementing-assertfloateqall">Implementing AssertFloatEqAll</a></h3>
<p>Requires <a href="../../doc/float_eq/trait.FloatEqUlpsTol.html">FloatEqUlpsTol</a>, <a href="../../doc/float_eq/trait.FloatEq.html">FloatEq</a>, <a href="../../doc/float_eq/trait.FloatEqAll.html">FloatEqAll</a>, <a href="../../doc/float_eq/trait.FloatEqDebugUlpsDiff.html">FloatEqDebugUlpsDiff</a>
and <a href="../../doc/float_eq/trait.AssertFloatEq.html">AssertFloatEq</a>. Implementation is then usually a matter of simply calling
through to an underlying <a href="../../doc/float_eq/trait.AssertFloatEqAll.html">AssertFloatEqAll</a> method for each field in turn. If
not, you will need to take a close look at the descriptions of the algorithms on
a method by method basis:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AssertFloatEqAll for Point {
    type AllDebugTol = Self;

    fn debug_abs_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_abs_all_tol(&amp;other.x, tol),
            y: self.y.debug_abs_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_rmax_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_rmax_all_tol(&amp;other.x, tol),
            y: self.y.debug_rmax_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_rmin_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_rmin_all_tol(&amp;other.x, tol),
            y: self.y.debug_rmin_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_r1st_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_r1st_all_tol(&amp;other.x, tol),
            y: self.y.debug_r1st_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_r2nd_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;Self::AllTol
    ) -&gt; Self::AllDebugTol {
        Point {
            x: self.x.debug_r2nd_all_tol(&amp;other.x, tol),
            y: self.y.debug_r2nd_all_tol(&amp;other.y, tol),
        }
    }

    fn debug_ulps_all_tol(
        &amp;self,
        other: &amp;Self,
        tol: &amp;UlpsTol&lt;Self::AllTol&gt;,
    ) -&gt; UlpsTol&lt;Self::AllDebugTol&gt; {
        PointUlps {
            x: self.x.debug_ulps_all_tol(&amp;other.x, tol),
            y: self.y.debug_ulps_all_tol(&amp;other.y, tol),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../how_to/interpret_assert_failure_messages.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../background.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../how_to/interpret_assert_failure_messages.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../background.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
